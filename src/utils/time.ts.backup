import dayjs, { Dayjs } from 'dayjs'
import utc from 'dayjs/plugin/utc'
import timezone from 'dayjs/plugin/timezone'

dayjs.extend(timezone)
dayjs.extend(utc)
dayjs.tz.setDefault('Asia/Tokyo')

interface ExternalTimeResponse {
  datetime: string
  timezone: string
  utc_offset: string
}

let cachedServerTime: Dayjs | null = null
let lastFetchTime: number = 0
let timeOffset: number = 0
const CACHE_DURATION = 5 * 60 * 1000 // 5 minutes

async function fetchExternalTime(): Promise<Dayjs> {
  try {
    const response = await fetch(
      'https://worldtimeapi.org/api/timezone/Asia/Tokyo'
    )
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`)
    }

    const data: ExternalTimeResponse = await response.json()
    const serverTime = dayjs(data.datetime).tz('Asia/Tokyo')

    // Calculate offset between server time and local time
    const localTime = dayjs().tz('Asia/Tokyo')
    timeOffset = serverTime.diff(localTime)

    cachedServerTime = serverTime
    lastFetchTime = Date.now()

    return serverTime
  } catch (error) {
    console.warn(
      'Failed to fetch external time, falling back to local time:',
      error
    )
    return dayjs().tz('Asia/Tokyo')
  }
}

export async function getServerTime(): Promise<Dayjs> {
  const now = Date.now()

  if (cachedServerTime && now - lastFetchTime < CACHE_DURATION) {
    // Return cached time with elapsed offset
    const elapsed = now - lastFetchTime
    return cachedServerTime.add(elapsed, 'millisecond')
  }

  return await fetchExternalTime()
}

export function getTimeDrift(): number {
  return timeOffset
}

export function hasSignificantDrift(): boolean {
  return Math.abs(timeOffset) > 30000 // 30 seconds
}

export function getTimeStr(time: string): string {
  return dayjs(time).tz().format('HH:mm')
}

export function getTime(time: string) {
  return dayjs(time).tz()
}

export function now(): Dayjs {
  return dayjs().tz()
}

export async function nowAccurate(): Promise<Dayjs> {
  return await getServerTime()
}
